local vec3 = require "vec3"
local transf = require "transf"
local constructionutil = require "constructionutil"
local paramsutil = require "paramsutil"
local colliderutil = require "colliderutil"
local arrayUtils = require('lollo_lorry_station/arrayUtils')
local _modConstants = require('lollo_lorry_station/constants')
local edgeUtils = require('lollo_lorry_station/edgeHelpers')
local slotUtils = require('lollo_lorry_station/slotHelpers')
local transfUtils = require('lollo_lorry_station/transfUtils')
local debugger = require('debugger')
local inspect = require('lollo_lorry_station/inspect')
local luadump = require('lollo_lorry_station/luadump')
local _idTransf = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}

local _constants = arrayUtils.addProps(
	{
		-- cargoAreaSpacing = {0.0, 0.0, 0.0, 0.0},
		cargoAreaSpacing = {0.5, 0.5, 0.5, 0.5},
		-- LOLLO NOTE spacing:
		-- the smaller these guys, the closer to the road I can fill a slot without it turning red.
		-- negative values don't matter, the api takes up the abs value
		-- 0 will make a module unselectable when the user wants to delete it
		-- the 3rd and 4th params may have to do with Y and the 1st and 2nd with X,
		-- probably 1 = x before, 2 = x after, 3 = y before, 4 = y after
		-- lorryBaySpacing = {0.1, 0.1, 0.1, 0.1},
		lorryBaySpacing = {0.5, 0.5, 0.5, 0.5},
		-- lorryBaySpacing = {0, 0, 0, 0},
		idBases = {
			areaSlotIdBase = 130000,
			rightBaySlotIdBase = 120000,
			leftBaySlotIdBase = 110000,
			centreSlotIdBase = 100000,
		},
		idFactorY = 100,
	},
	_modConstants
)
local _idBasesSortedDesc = {}
for k, v in pairs(_constants.idBases) do
    table.insert(_idBasesSortedDesc, {id = v, name = k})
end
arrayUtils.sort(_idBasesSortedDesc, 'id', false)

function data()
	return {
		type = "STREET_STATION_CARGO",
		-- type = "STREET_STATION",
		-- type = 'STREET_CONSTRUCTION',
		description = {
			name = _("Lollo lorry station construction"),
			description = _("Lollo lorry station construction."),
		},
		availability = {
			yearFrom = 0,
			yearTo = 0
		},
		params = {
			-- {
			-- 	key = 'lockLayoutCentre',
			-- 	name = _('Lock curve'),
			-- 	tooltip = _('Lock a curve to keep its shape pretty and prevent other roads merging in. Unlock it to treat it like ordinary roads. You cannot relock an unlocked curve.'),
			-- 	values = {
			-- 		_('No'),
			-- 		_('Yes')
			-- 	},
			-- 	defaultIndex = 0
			-- },
		},
		-- hasCargoPlatform = true, -- useless
		-- streetTerminal = { -- useless
		-- 	cargo = true,
		-- },
		order = 5005,

		skipCollision = true,
		updateFn = function(params)
			local result = {
				colliders = {},
				coord2terminalInfo = {},
				cost = 1000,
				edgeLists = {},
				groundFaces = {},
				models = {},
				slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = {}
			}
			print('LOLLO starting updateFn, params = ')
			luadump(true)(params)
			-- debugger()

			local _occupiedSlots = {}
			local _isSlotOccupied = function(x, y)
				return slotUtils.getValueFromNestedTable(_occupiedSlots, x, y) == true
				-- if _occupiedSlots[edgeUtils.getXKey(x)] == nil then return false end
				-- if _occupiedSlots[edgeUtils.getXKey(x)][edgeUtils.getYKey(y)] then return true end
				-- return false
			end
			local _setSlotOccupied = function(x, y)
				slotUtils.setValueInNestedTable(_occupiedSlots, true, x, y)
				-- if _occupiedSlots[edgeUtils.getXKey(x)] == nil then _occupiedSlots[edgeUtils.getXKey(x)] = {} end
				-- _occupiedSlots[edgeUtils.getXKey(x)][edgeUtils.getYKey(y)] = true
			end

			local _addModel = function(fileName, transf, tag)
				table.insert(result.models, {
					id = fileName,
					tag = tag,
					transf = transf,
				})
			end

			result.MangleId = function(x, y, baseId)
				return baseId + _constants.idFactorY * (y  - _modConstants.yMin) + (x  - _modConstants.xMin)
			end

			result.DemangleId = function(slotId)
				local function _getIdBase(slotId)
					local baseId = 0
					for _, v in pairs(_idBasesSortedDesc) do
						if slotId >= v.id then
							baseId = v.id
							break
						end
					end

					return baseId > 0 and baseId or false
				end

				local baseId = _getIdBase(slotId)
				if not baseId then return false, false, false end

				local y = math.floor((slotId - baseId) / _constants.idFactorY)
				local x = math.floor((slotId - baseId - y * _constants.idFactorY))

				return x + _modConstants.xMin, y + _modConstants.yMin, baseId
			end

			-- add the streets leading into the station
--[[ 			result.edgeLists = {
				{
					type = 'STREET',
					alignTerrain = false,
					params = {
						busLaneType = 'YES', -- does not pull, neither do hasBusLane and busLane, with true or false
						busLane = 'YES',
						hasBusType = 'YES',
						hasBus = true,
						skipCollision = true,
						--skipCollisionCheck = true,
						-- type = 'standard/country_medium_new.lua',
						type = 'internal_collision_free_road.lua',
						tramTrackType = 'NO' -- tramTrackType
					},
					edges = {
						{ { -10, -10, 0 }, { 0, 1, 0 } },
						{ { -10, -1, 0 }, { 0, 1, 0 } },
						-- { { -10, 0, 0 }, { 0, 1, 0 } },
					},
					freeNodes = {0},
					snapNodes = {0},
					skipCollision = true,
					--					tag2nodes = {},
				},
				{
					type = 'STREET',
					alignTerrain = false,
					params = {
						skipCollision = true,
						--skipCollisionCheck = true,
						-- type = 'standard/country_medium_new.lua',
						type = 'internal_collision_free_road.lua',
						tramTrackType = 'NO' -- tramTrackType
					},
					edges = {
						{ { -10, 1, 0 }, { 0, 1, 0 } },
						-- { { -10, 0, 0 }, { 0, 1, 0 } }, -- LOLLO TODO if the edges touch the vehicle node, it dumps
						{ { -10, 10, 0 }, { 0, 1, 0 } },
					},
					freeNodes = {1},
					snapNodes = {1},
					skipCollision = true,
					--					tag2nodes = {},
				},
			} ]]

			-- add the lorry bay at 0, 0
			-- _addModel(_modConstants.lorryBayModelFileName, _idTransf, _modConstants.lorryBayTag)
			-- slotUtils.setValueInNestedTable(
			-- 	result.coord2terminalInfo,
			-- 	{
			-- 		model = #result.models - 1, -- position with base 0
			-- 		terminal = 0 -- always 0, it seems
			-- 	},
			-- 	0,
			-- 	0
			-- )
			-- _setSlotOccupied(0, 0)

			-- add the default model at 0, 0
			-- _addModel(_modConstants.markModelFileName, _idTransf, _modConstants.markTag)
			
			-- add cargo area slots
			local slotXYs = { -- default lorry bay
				['-1'] = {
					['0'] = true,
				},
				['0'] = {
					['-1'] = true,
					['0'] = true,
					['1'] = true
				},
				['1'] = {
					['0'] = true,
				}
			}
			if type(params.modules) == 'table' then
				for moduId, _ in pairs(params.modules) do
					local moduleX, moduleY, moduleBaseId = result.DemangleId(moduId)
					if moduleBaseId == _constants.idBases.areaSlotIdBase 
					or moduleBaseId == _constants.idBases.rightBaySlotIdBase
					or moduleBaseId == _constants.idBases.leftBaySlotIdBase then
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX, moduleY)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX, moduleY + 1)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX + 1, moduleY)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX, moduleY - 1)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX - 1, moduleY)
					end
				end
			end
			local adjacentXYs = slotUtils.getFlatTable(slotXYs)
			-- print('LOLLO adjacentXYs = ')
			-- luadump(true)(adjacentXYs)
			for _, v in pairs(adjacentXYs) do
				_setSlotOccupied(v.x, v.y)
				table.insert(result.slots, {
					id = result.MangleId(v.x, v.y, _constants.idBases.areaSlotIdBase),
					transf = transf.transl(vec3.new(v.x * _modConstants.xTransfFactor, v.y * _modConstants.yTransfFactor, 0.0)),
					-- type = "street_terminal_passenger",
					type = _modConstants.cargoAreaModuleType,
					spacing = _constants.cargoAreaSpacing,
					-- height
					-- shape 1 2 3 4
				})
			end

			-- add lorry bay slots
			-- no access to api or interface, I must work with the params.
			if type(params.streetNodeGroups) == 'table' and type(params.transf) == 'table' and type(params.inverseTransf) == 'table' then
				for _, nodeGroup in pairs(params.streetNodeGroups) do
					print('LOLLO params.inverseTransf = ')
					luadump(true)(params.inverseTransf)
					local absolutePosition = nodeGroup[2][1]
					print('LOLLO absolutePosition = ')
					luadump(true)(absolutePosition)
					-- LOLLO TODO make relative coordinates, relative to the transf. This looks good but it is probably too stupid
					local relativePosition = {
						absolutePosition[1] - params.transf[13],
						absolutePosition[2] - params.transf[14],
					}
					print('LOLLO relativePosition 1 = ')
					luadump(true)(relativePosition)
					-- this should be better
					local relativePosition = transfUtils.getVec123Transformed(absolutePosition, params.inverseTransf)
					print('LOLLO relativePosition 2 = ')
					luadump(true)(relativePosition)

					local tangents = nodeGroup[2][2]
					-- _setSlotOccupied(x, y)
					-- table.insert(
					-- 	result.slots,
					-- 	{
					-- 		id = result.MangleId(
					-- 			math.floor(relativePosition[1] / _modConstants.xTransfFactor),
					-- 			math.floor(relativePosition[2] / _modConstants.yTransfFactor),
					-- 			-- math.ceil(relativePosition[1] / _modConstants.xTransfFactor),
					-- 			-- math.ceil(relativePosition[2] / _modConstants.yTransfFactor),
					-- 			_constants.idBases.leftBaySlotIdBase
					-- 		),
					-- 		transf = transfUtils.mul(
					-- 			transf.rotZTransl(
					-- 				math.pi / 2.0 + math.atan2(tangents[2], tangents[1]),
					-- 				vec3.new(absolutePosition[1], absolutePosition[2], absolutePosition[3])
					-- 				-- vec3.new(relativePosition[1], relativePosition[2], 0)
					-- 			),
					-- 			params.inverseTransf
					-- 		),
					-- 		type = _modConstants.lorryBayModuleType,
					-- 		spacing = _constants.lorryBaySpacing,
					-- 		skipCollision = true, -- useless
					-- 		-- height
					-- 		-- shape
					-- 	}
					-- )
					-- LOLLO TODO put left and right into separate slots
					-- or only do one, and only use 1-way roads (easier)
					print('LOLLO absolutePosition[3] =', absolutePosition[3])
					table.insert(
						result.slots,
						{
							-- LOLLO TODO try changing the id to avoid red dots in the grid
							-- basically, try getting the dot out of the road
							-- the rest seems fine: add some shift in the lorry bay module, 
							-- build a lorry bay,
							-- remove the shift, build a cargo area: it is all nice and level
							-- except for that red dot, that is.
							id = result.MangleId(
								math.floor(relativePosition[1] / _modConstants.xTransfFactor),
								math.floor(relativePosition[2] / _modConstants.yTransfFactor),
								_constants.idBases.rightBaySlotIdBase
							),
							transf = transfUtils.mul(
								transf.rotZTransl(
									- math.pi / 2.0 + math.atan2(tangents[2], tangents[1]),
									vec3.new(absolutePosition[1], absolutePosition[2], absolutePosition[3])
									-- vec3.new(absolutePosition[1], absolutePosition[2], 0)
									-- vec3.new(absolutePosition[1], absolutePosition[2], 11)
									-- vec3.new(relativePosition[1], relativePosition[2], 0)
								),
								params.inverseTransf
							),
							type = _modConstants.lorryBayModuleType,
							spacing = _constants.lorryBaySpacing,
							skipCollision = true, -- useless
							-- height
							-- shape
						}
					)
				end
			end

			result.terminateConstructionHook = function(one, two)
				print('LOLLO starting terminateConstructionHook')
				luadump(true)(one)
				luadump(true)(two)
				-- this fires after the user has added a module
				local station = { terminals = {}, tag = 0 } -- tag = 0 means cargo
				local cargoAreaModelIndexesBase0 = slotUtils.getCargoAreaModelIndexesBase0(result.models)
				-- LOLLO TODO in future, take only non-adjacent lorry bays
				local lorryBayModelIndexesBase0 = slotUtils.getLorryBayModelIndexesBase0(result.models)

				local tagCounterBase0 = 0
				result.terminalGroups = {}
				for _, bay in pairs(lorryBayModelIndexesBase0) do
					table.insert(result.terminalGroups, {tag = tagCounterBase0, terminals = { { bay.base0ModelIndex, 0 }}})

					local adjacentCargoAreas = slotUtils.getAdjacentValues(cargoAreaModelIndexesBase0, bay.x, bay.y)
print('LOLLO adjacentCargoAreas = ')
luadump(true)(adjacentCargoAreas)
					for _, v in pairs(adjacentCargoAreas) do
						table.insert(result.terminalGroups[#result.terminalGroups].terminals, {v, 0})
					end

					tagCounterBase0 = tagCounterBase0 + 1
				end

				result.stations = {
					{
						tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
						terminals = { } -- 0 is the position of the linked terminal group, in base 0
					}
				}
				for lorryBayCounter = 1, tagCounterBase0 do
					table.insert(result.stations[1].terminals, lorryBayCounter - 1)
				end
				-- avoid dump when configuring
				if #(result.stations[1].terminals) == 0 then
					table.insert(result.stations[1].terminals, 0)
				end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- LOLLO stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- LOLLO stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep the m all different tho
				-- 		terminals = {
				-- 		{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 		{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- test: add road connections to lorry bays
				-- LOLLO TODO add road connections to lorry bays, with the appropriate transf,
				-- basing on params.streetEdges and result.models with lorry bay tag
				-- _addModel(_modConstants.roadConnectionFileName, _idTransf, _modConstants.roadConnectionTag)

				print('LOLLO lollo_lorry_station leaving terminateConstructionHook')
				if #station.terminals > 0 then table.insert(result.stations, station) end
				print('LOLLO result.models = ')
				luadump(true)(result.models)
				print('LOLLO result.stations = ')
				luadump(true)(result.stations)
				print('LOLLO result.terminalGroups = ')
				luadump(true)(result.terminalGroups)
			end

			local isNoLorryBays = true
			if type(params.modules) == 'table' then
				for _, modu in pairs(params.modules) do
					print('LOLLO modu =')
					if modu.metadata.lorryBay then
						isNoLorryBays = false
						break
					end
				end
			end
			if isNoLorryBays and type(params.models) == 'table' then
				local lorryBayModelIndexesBase0 = slotUtils.getLorryBayModelIndexesBase0(result.models)
				print('LOLLO #lorryBayModelIndexesBase0 =', #lorryBayModelIndexesBase0)
				if #lorryBayModelIndexesBase0 > 0 then
					isNoLorryBays = false
				end
			end
			-- if params.modules[result.MangleId({0, 0, 0})] == nil and params.modules[result.MangleId({-1, 0, 0})] == nil
			-- and params.modules[result.MangleId({0, 0, 1})] == nil and params.modules[result.MangleId({-1, 0, 1})] == nil
			-- and params.modules[result.MangleId({55, 0, 3})] == nil and params.modules[result.MangleId({55, 0, 4})] == nil and params.modules[result.MangleId({55, 0, 5})] == nil
			-- and params.modules[result.MangleId({55, 1, 3})] == nil and params.modules[result.MangleId({55, 1, 4})] == nil and params.modules[result.MangleId({55, 1, 5})] == nil then
			if isNoLorryBays then
				table.insert(result.models, {
					-- id = "asset/icon/marker_exclamation.mdl",
					id = _modConstants.markModelFileName,
					transf = transf.transl(vec3.new(0.0, 0.0, 0.0)),
				})
			end

			print('LOLLO lollo_lorry_station leaving updateFn, result = ')
			luadump(true)(result)

			return result
		end,
		upgradeFn = function(_)
			debugger() -- it does not get here when I call it with game.interface.upgradeConstruction()
		-- 	-- LOLLO NOTE the game wants this function to be defined, even if it returns an empty table.
		-- 	-- If you leave it out, adding and removing tram tracks won't work.
		-- 	-- (Bus lanes don't work anyway.)
		-- 	return {}
		end,
	}
end