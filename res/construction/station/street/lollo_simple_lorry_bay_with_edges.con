local arrayUtils = require('lollo_lorry_station/arrayUtils')
local _idTransf = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}
local _constants = require('lollo_lorry_station/constants')
local slotUtils = require('lollo_lorry_station/slotHelpers')
local transf = require "transf"
local vec3 = require "vec3"

function data()
	local function _getTramTrackType(params)
		return params.tramTrack == 0 and "NO" or params.tramTrack == 1 and "YES" or "ELECTRIC"
		-- return params.tramTrack and (({'NO', 'YES', 'ELECTRIC'})[params.tramTrack + 1]) or 'NO'
	end

	return {
		type = 'STREET_STATION_CARGO',
		-- type = 'STREET_STATION',
		-- type = 'STREET_CONSTRUCTION',
		description = {
			name = _("Lollo simple roadside lorry bay with edges"),
			description = _("Lollo simple roadside lorry bay with edges."),
		},
		availability = {
			yearFrom = 0,
			yearTo = 0
		},
		params = {
			-- {
			-- 	key = 'lockLayoutCentre',
			-- 	name = _('Lock curve'),
			-- 	tooltip = _('Lock a curve to keep its shape pretty and prevent other roads merging in. Unlock it to treat it like ordinary roads. You cannot relock an unlocked curve.'),
			-- 	values = {
			-- 		_('No'),
			-- 		_('Yes')
			-- 	},
			-- 	defaultIndex = 0
			-- },
		},
		order = 5005,
		autoRemovable = false,
		skipCollision = true,
		updateFn = function(params)
			local result = {
				colliders = {},
				coord2terminalInfo = {},
				cost = 1000,
				edgeLists = {
					{
						type = 'STREET',
						params = {
							-- skipCollision = true,
							type = 'standard/country_medium_new.lua',
							tramTrackType = 'NO' --_getTramTrackType(params)
						},
						edges = {
							{
								{-11, -6 + _constants.lorryBayYShift, 0},
								{10, 0, 0},
							},
							{
								{-1, -6 + _constants.lorryBayYShift, 0},
								{10, 0, 0},
							},
						},
						freeNodes = {},
						snapNodes = {0}, -- LOLLO NOTE all edge nodes must be non free, to avoid collisions when configuring a finalised station
						-- skipCollision = true,
					},
					{
						type = 'STREET',
						params = {
							-- skipCollision = true,
							type = 'standard/country_medium_new.lua',
							tramTrackType = 'NO' --_getTramTrackType(params)
						},
						edges = {
							{
								{-1, -6 + _constants.lorryBayYShift, 0},
								{2, 0, 0},
							},
							{
								{1, -6 + _constants.lorryBayYShift, 0},
								{2, 0, 0}
							},
						},
						freeNodes = {},
						snapNodes = {},
						-- skipCollision = true,
					},
					{
						type = 'STREET',
						params = {
							skipCollision = true,
							type = 'standard/country_medium_new.lua',
							tramTrackType = 'NO' --_getTramTrackType(params)
						},
						edges = {
							{
								{1, -6 + _constants.lorryBayYShift, 0},
								{10, 0, 0}
							},
							{
								{11, -6 + _constants.lorryBayYShift, 0},
								{10, 0, 0}
							}
						},
						freeNodes = {},
						snapNodes = {1},
					 skipCollision = true,
					},
				},
				groundFaces = {},
				models = {
					{
						id = 'lollo_models/lollo_simple_lorry_bay.mdl',
						-- tag = slotUtils.getCargoAreaModelTag(slotId),
						tag = slotUtils.getLorryBayModelTag(slotUtils.mangleId(0, 0, _constants.idBases.leftBaySlotIdBase)),
						transf = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, _constants.lorryBayYShift, 0, 1},
					},
				},
				slotConfig = {
					-- [_constants.cargoAreaModuleType] = {
					-- 	maxModules = -1,
					-- 	message = nil, --'LOLLO slotConfig message',
					-- 	skipCollisionCheck = true,
					-- },
					[_constants.streetsideCargoAreaModuleType] = {
						maxModules = -1,
						message = nil, --'LOLLO slotConfig message',
						skipCollisionCheck = true,
					}
				},
				slots = {},
				stations = {},
				terminalGroups = {},
				terrainAlignmentLists = {},
				DemangleId = slotUtils.demangleId,
				MangleId = slotUtils.mangleId,
			}

			-- print('LOLLO starting lollo_simple_lorry_bay_with_edges.updateFn, params = ')
			-- debugPrint(arrayUtils.cloneOmittingFields(params, {'state'}))

			local _occupiedSlots = {}
			local _isSlotOccupied = function(x, y)
				return slotUtils.getValueFromNestedTable(_occupiedSlots, x, y) == true
			end
			local _setSlotOccupied = function(x, y)
				slotUtils.setValueInNestedTable(_occupiedSlots, true, x, y)
			end

			-- bar main slot, the one with the vehicle loading bay
			_setSlotOccupied(0, 0)
			-- set default slot locations
			local slotXYs = {
				['-1'] = {
					['0'] = true,
				},
				['0'] = {
					['-1'] = true,
					['0'] = true, -- the main unit, with the vehicle loading bay
					['1'] = true
				},
				['1'] = {
					['0'] = true,
				}
			}
			-- fill slots on and around modules, if present
			if type(params.modules) == 'table' then
				for moduId, _ in pairs(params.modules) do
					local moduleX, moduleY, moduleBaseId = result.DemangleId(moduId)
					if moduleBaseId == _constants.idBases.streetsideCargoAreaSlotId
					or moduleBaseId == _constants.idBases.cargoAreaSlotId
					or moduleBaseId == _constants.idBases.rightBaySlotIdBase
					or moduleBaseId == _constants.idBases.leftBaySlotIdBase then
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX, moduleY)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX, moduleY + 1)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX + 1, moduleY)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX, moduleY - 1)
						slotUtils.setValueInNestedTable(slotXYs, true, moduleX - 1, moduleY)
						-- bar building in front of a streetside cargo area
						if moduleBaseId == _constants.idBases.streetsideCargoAreaSlotId then
							_setSlotOccupied(moduleX, moduleY - 1)
						end
					end
				end
			end
			local adjacentXYs = slotUtils.getFlatTable(slotXYs)
			-- print('LOLLO adjacentXYs = ')
			-- debugPrint(adjacentXYs)

			-- add streetside cargo area slots, only along the road
			for _, v in pairs(adjacentXYs) do
				-- print('LOLLO v.y =', v.y, 'its type =', type(v.y))
				if (v.y == '0' or v.y == 0) and not(_isSlotOccupied(v.x, v.y)) then
					-- _setSlotOccupied(v.x, v.y)
					table.insert(result.slots, {
						-- height = 1,
						id = result.MangleId(v.x, v.y, _constants.idBases.streetsideCargoAreaSlotId),
						-- shape 1 2 3 4
						spacing = _constants.streetsideCargoAreaSpacing,
						transf = transf.transl(vec3.new(v.x * _constants.xTransfFactor, v.y * _constants.yTransfFactor + _constants.lorryBayYShift, 0.0)),
						type = _constants.streetsideCargoAreaModuleType,
					})
				end
			end

			-- add cargo area slots
			-- -- bar slots along the road and in its middle
			-- _setSlotOccupied(0, 0)
			_setSlotOccupied(0, -1)
			_setSlotOccupied(-1, 0)
			_setSlotOccupied(1, 0)
			for _, v in pairs(adjacentXYs) do
				if not(_isSlotOccupied(v.x, v.y)) then
					-- _setSlotOccupied(v.x, v.y)
					table.insert(result.slots, {
						-- height = 1,
						id = result.MangleId(v.x, v.y, _constants.idBases.cargoAreaSlotId),
						-- shape 1 2 3 4
						spacing = _constants.cargoAreaSpacing,
						transf = transf.transl(vec3.new(v.x * _constants.xTransfFactor, v.y * _constants.yTransfFactor, 0.0)),
						type = _constants.cargoAreaModuleType,
					})
				end
			end

			-- join terminals together
			result.terminateConstructionHook = function(one, two)
				-- this fires after the user has added a module
				-- print('LOLLO starting terminateConstructionHook')
				-- print('LOLLO result.models =')
				-- debugPrint(result.models)
				-- local station = { terminals = {}, tag = 0 } -- tag = 0 means cargo
				local cargoAreaModelIndexesBase0 = slotUtils.getCargoAreaModelIndexesBase0(result.models)
				-- print('LOLLO cargoAreaModelIndexesBase0 =')
				-- debugPrint(cargoAreaModelIndexesBase0)
				-- LOLLO TODO in future, if you add more lorry bays, only take the non-adjacent ones
				local lorryBayModelIndexesBase0 = slotUtils.getLorryBayModelIndexesBase0(result.models)
				-- print('LOLLO lorryBayModelIndexesBase0 =')
				-- debugPrint(lorryBayModelIndexesBase0)

				result.stations = {
					{
						tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
						terminals = { } -- 0 is the position of the linked terminal group, in base 0
					}
				}
				result.terminalGroups = {}
				local bayIndexBase0 = 0
				for _, bay in pairs(lorryBayModelIndexesBase0) do
					table.insert(
						result.terminalGroups,
						{tag = bayIndexBase0, terminals = { { bay.base0ModelIndex, 0 }}}
					)

					local adjacentCargoAreas = slotUtils.getAdjacentValues(cargoAreaModelIndexesBase0, bay.x, bay.y)
					-- print('LOLLO adjacentCargoAreas = ')
					-- debugPrint(adjacentCargoAreas)
					for _, v in pairs(adjacentCargoAreas) do
						table.insert(result.terminalGroups[#result.terminalGroups].terminals, {v, 0})
					end

					table.insert(result.stations[1].terminals, bayIndexBase0)
					bayIndexBase0 = bayIndexBase0 + 1
				end

				-- for lorryBayCounter = 1, tagCounterBase0 do
				-- 	table.insert(result.stations[1].terminals, lorryBayCounter - 1)
				-- end
				-- avoid dump when configuring
				if #(result.stations[1].terminals) == 0 then
					table.insert(result.stations[1].terminals, 0)
				end

				-- it should output something like (this example has one terminal made of two adjacent bits)
				-- stock result.stations =
				-- 	{
				-- 		{
				-- 			tag = 0, -- in the stock station, this is 0 for cargo and 1 for passengers
				-- 			terminals = { 0 } -- 0 is the position of the linked terminal group, in base 0
				-- 		}
				-- 	}
				-- stock result.terminalGroups =
				-- {
				-- 	{
				-- 		tag = -1, -- possibly useless, try to keep the m all different tho
				-- 		terminals = {
				-- 			{ 22, 0 }, -- 22 is the position of a model with a terminal, in base 0
				-- 			{ 25, 0 }, -- 0 is always 0 in the stock station, it is something like a terminal number
				-- 		}
				-- 	}
				-- }

				-- print('LOLLO lollo_lorry_station leaving terminateConstructionHook')
				-- if #station.terminals > 0 then table.insert(result.stations, station) end
				-- print('LOLLO result.models = ')
				-- debugPrint(result.models)
				-- print('LOLLO result.stations = ')
				-- debugPrint(result.stations)
				-- print('LOLLO result.terminalGroups = ')
				-- debugPrint(result.terminalGroups)
			end

			-- print('LOLLO lollo_simple_lorry_bay_with_edges leaving updateFn, result = ')
			-- debugPrint(result)

			return result
		end,
		upgradeFn = function(_)
		-- it does not get here when I call it with game.interface.upgradeConstruction()
		-- 	-- LOLLO NOTE the game wants this function to be defined, even if it returns an empty table.
		-- 	-- If you leave it out, adding and removing tram tracks won't work.
		-- 	-- (Bus lanes don't work anyway.)
			return {}
		end,
	}
end